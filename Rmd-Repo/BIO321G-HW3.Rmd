---
title: "BIO321G-HW3"
author: "ArunK"
date: "9/17/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---

```{r}
eulerIntegrate = function(f, x0, dt, tEnd){
  out = data.frame(
    t = seq(from=0, to=tEnd, by=dt),
    x = x0
  )
  xNow = x0
  for (step in 2:nrow(out)){
    dx = f(xNow) * dt
    xNow = xNow + dx
    out[step, "x"] = xNow
  }
  return(out)
}
```

### Problem 1
```{r}
fLogistic <- function(x, r, k){
  r*x*(1-(x/k))
}
```

### Problem 2
```{r}
setParameters <- function(f, parameters){
  fWithParametersFixed = function(x){
    argumentsForF = c(x, parameters)
    return(do.call(f, argumentsForF))
  }
  return(fWithParametersFixed)
}

pars = list(r=1,k=10)
fParametrized = setParameters(fLogistic, pars)
fParametrized(1)
fParametrized(5)
fParametrized(10)
```
`fParameterized(1)` returns $0.9$, `fParameterized(5)` returns $2.5$, and `fParameterized(10)` returns $0$.

### Problem 3 
`setParameters()` is taking the function `f` and using a `do.call` to suppy the list of parameter values, here `r` and `k`; the result is that we only have to specify the `x` argument to `fParametrized`. Correspondingly, the argument `parameters` must be a list of named arguments for the function `f`.

### Problem 4
```{r}
vecPars = c(r=1, k =10)
# fParametrized2 = setParameters(fLogistic, vecPars)
# fParametrized2(5)
```
Trying to apply the parameterization function with vectorized arguments returns an error. `do.call` requires a `list` of arguments, and cannot coerce the given vector data type into a list. 

### Problem 5
We should use `fParameterized` as the argument `f` to `eulerIntegrate`. The `eulerIntegrate` function includes arguments for the function to be integrated, time integration bounds and time step only; we would be unable to specify the logistic growth parameters `k` and `r` for the function `fLogistic`. By using `fParameterized`, we are passing in a function with set parameter values, making it a function of `x` only, which is what `eulerIntegrate` is ultimately aimed at integrating.

### Problem 6
```{r}
eulerTraj <- data.frame(eulerIntegrate(fParametrized, 1, .2, 6))

library(ggplot2)
theme_set(theme_bw())
gg = ggplot(eulerTraj, aes(x=t,y=x))+ geom_point() + geom_line()
print(gg)
```

### Problem 7 
```{r}
exactSolutionLogisticGrowth = function(r, k, x0){
  tStar = log((k/x0)-1)/r
  solution = function(t){
    k/(1+exp(-r*(t-tStar)))
  }
  return(solution)
}

gg = ggplot(eulerTraj, aes(x=t,y=x))+ geom_point() + geom_line() + stat_function(fun = exactSolutionLogisticGrowth(r = 1, k = 10, x0 = 1), col = "chartreuse2")
print(gg)

```

### Problem 8
```{r}
eulerTraj_large <- data.frame(eulerIntegrate(fParametrized, 1, 3, 60))

gg_large = ggplot(eulerTraj_large, aes(x=t,y=x))+ geom_point() + geom_line() + stat_function(fun = exactSolutionLogisticGrowth(r = 1, k = 10, x0 = 1), col = "chartreuse2")
print(gg_large)
```

Compared to the result of **7**, there is a noticeably larger disparity between the exact and Euler method solutions. Previously, the two methods were quiet similar in trajectory, especially near the start and end; the Euler trajectory now oscillates in a seemingly random fashion even after the exact solution has stabilized at the `k` value. 

### Problem 9 
A. Eq (8) is equivalent to the logistic map model in discrete time.  
B. $\tilde{r} = 1+ (1)(3) = 4$  
C. We know that for any $r$ value greater than 3 in the logistic map model, we should expect increasingly disorderly behavior; a logistic map model with $r$ value of $4$ would exhibit chaotic behavior, and never settle to a single value; this is also what we see from the Euler trajectory in **8**.   





